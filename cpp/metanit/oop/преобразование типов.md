**Upcast -** повышающее преобразование - приведение типа к родительскому типу, выше по иерархии. D В с++ upcast можно сделать неявно.
Пример неявного upcast:
```
class Person {
public:
	std::string name;
};

class Employee: public Person {
public: 
	std::string workplace;
};

int main() {
	Employee employee("Bob");

	Person person = Person(employee); //implicit upcast via copy constructor
	Person person2();
	person2 = employee; //implicit upcast via copy assignment operator
}
```
Указатели можно upcast неявно тоже:
```
Employee bob;
Person* personPointer = Person(&bob);
```
Также upcast работает неявно с ссылками:
```
Employee sam;
Person &person1(sam);
```
**Downcast -** понижающее преобразование - приведение типа к типу потомка. Делается только явно и не всегда.
Для явных преобразований можно использовать **static_cast<>();**

**Crosscast** - преобразование типов на одном уровне в иерархии при множественном наследовании. 

### подробнее о downcast
downcast может быть только явным через static_cast() и другие методы явного преобразования. 
Downcast работает только с некоторыми объектами.
Например, если в указателе типа Person* лежит ссылка на объект класса Employee, то мы можем сделать downcast от Person* к Employee*. В обратном случае возникло бы undefined behaviour.
```
Employee sam("Sam", "Google");
Person* person = &sam;
Employee* employee = static_cast<Employee*>(person);
```

Но бывают ситуации, когда downcast невозможен: Вроде бы все пройдет успешно, но методы производного класса будут недоступны. И вообще это UB и плохо.
```
Person tom("tom")
Person* person = &tom;
Employee* employee = static_cast<Employee*>(person); 
```

#### static_cast<>()
-выполняется во время компиляции. Поэтому необходимо, чтобы операнды static_cast были известны еще на момент компиляции. Если такой вариант не устраивает, можно использовать **dynamic_cast<>()**
#### dynamic_cast<>()
-выполняет преобразование в рантайме, работает только с указателями или ссылками на полиморфные классы. Если каст не удался, возвращается nullptr. Если мы делаем dynamic_cast с указателя на константу, то и результирующий тип - тоже указатель на константу. 
Еще dynamic_cast умеет работать с ссылками, но тогда в случае неудачи он выбросит ошибку std::bad_cast.

*P.S. Полиморфные классы -  содержат хотя бы одну виртуальную функцию.* 

#### const_cast<>()
-позволяет добавлять или убирать cv-qualifier const к типу. Работает с простыми типами, пользовательскими типами, указателями и ссылками - со всем работает. 
Антипод слова const - слово volatile. 

#### приведение типов в стиле C
такое же как в java, ставим в скобках результирующий тип. Но приведение типов из С не умеет проверять возможность преобразования.

#### reinterpret_cast 
-используется для приведения несовместимых типов. Может приводить целое число к указателю, указатель к целому числу, ссылки к указателю - вообще полный беспредел. Фактически творит то же самое, что и приведение в стиле С. За исключением того, что не меняет cv-qualifiers.
